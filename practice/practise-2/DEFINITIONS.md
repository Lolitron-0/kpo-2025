# Список терминов семинара
###### Нужно написать определения с примером из жизни или кода
### 1. **KISS (Keep It Simple, Stupid)**
**Определение:**  
Принцип программирования, который рекомендует делать код простым и понятным. Простота облегчает поддержку и уменьшает вероятность ошибок.

**Пример из жизни:**  
Сложный рецепт торта заменяется простым, где используются доступные ингредиенты и минимальное количество действий.

**Пример кода:**  
Плохо:
```java
public int calculateSum(int a, int b) {
    if (a > 0 && b > 0) {
        return a + b;
    } else {
        return a + b;
    }
}
```
Хорошо:
```java
public int calculateSum(int a, int b) {
    return a + b;
}
```

---

### 2. **DRY (Don't Repeat Yourself)**
**Определение:**  
Принцип, который предполагает избегание дублирования кода. Каждый кусок информации должен быть представлен в системе единожды.

**Пример из жизни:**  
Если один раз написать расписание и скопировать для всех сотрудников, это проще, чем писать расписание каждому отдельно.

**Пример кода:**  
Плохо:
```java
public int add(int a, int b) {
    return a + b;
}

public int sum(int a, int b) {
    return a + b;
}
```
Хорошо:
```java
public int add(int a, int b) {
    return a + b;
}
```

---

### 3. **YAGNI (You Aren't Gonna Need It)**
**Определение:**  
Принцип, который утверждает: "Не реализуй функциональность, пока она не понадобится".

**Пример из жизни:**  
Не стоит учить китайский язык, если вы планируете поездку в Европу.

**Пример кода:**  
Плохо:
```java
public void processData() {
    // Код для обработки данных
    sendEmail(); // Метод, который пока не используется
}

public void sendEmail() {
    // Код для отправки email
}
```
Хорошо:
```java
public void processData() {
    // Код для обработки данных
}
```

---

### 4. **BDUF (Big Design Up Front)**
**Определение:**  
Методология разработки, предполагающая создание детализированного плана и архитектуры перед началом кодирования.

**Пример из жизни:**  
Строительство дома начинается с создания подробного архитектурного проекта.

**Пример:**  
Перед созданием сложной системы разрабатывается диаграмма UML и подробное техническое задание.

---

### 5. **SOLID (Каждая буква)**
1. **S (Single Responsibility Principle)** – Принцип единственной ответственности. Класс должен иметь только одну причину для изменения.  
   Пример: Класс `User` отвечает только за данные пользователя, а `UserManager` – за управление пользователями.

2. **O (Open/Closed Principle)** – Принцип открытости/закрытости. Классы должны быть открыты для расширения, но закрыты для модификации.  
   Пример: Добавление новой функции через интерфейс вместо изменения существующего класса.

3. **L (Liskov Substitution Principle)** – Принцип подстановки Барбары Лисков. Объекты подклассов должны заменять объекты суперклассов без изменения поведения.  
   Пример: Если `Bird` имеет метод `fly()`, то подкласс `Penguin` не должен его нарушать.

4. **I (Interface Segregation Principle)** – Принцип разделения интерфейсов. Интерфейсы должны быть узкоспециализированными, чтобы классы не реализовывали лишний функционал.  
   Пример: Лучше два интерфейса `Runnable` и `Flyable`, чем один огромный интерфейс.

5. **D (Dependency Inversion Principle)** – Принцип инверсии зависимостей. Модули зависят от абстракций, а не от конкретных реализаций.  
   Пример: Использование интерфейсов вместо жестких зависимостей.

---

### 6. **APO (Aspect-Oriented Programming)**
**Определение:**  
Методология, направленная на разделение кода на аспекты, чтобы вынести в отдельные модули сквозную функциональность (например, логирование, безопасность).

**Пример из жизни:**  
Уборка дома делится на аспекты: пылесосить, вытирать пыль, мыть окна.

**Пример кода:**  
С помощью AOP в Spring можно логировать выполнение методов без изменения их кода.

---

### 7. **Бритва Оккама**
**Определение:**  
Принцип минимизации. Если есть два объяснения, то предпочтение отдаётся самому простому.

**Пример из жизни:**  
Если дверь открыта, это скорее из-за ветра, чем из-за призраков.

---

### 8. **Stream API**
**Определение:**  
Stream API – функциональность Java, которая позволяет работать с данными в виде потоков. Она облегчает обработку коллекций с использованием методов, таких как фильтрация, сортировка и преобразование.

**Основные методы:**
- `filter()` – фильтрация данных.
- `map()` – преобразование элементов.
- `forEach()` – выполнение действий над каждым элементом.
- `collect()` – сбор результата в коллекцию.
- `reduce()` – свёртка данных.

**Пример кода:**
```java
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        numbers.stream()
               .filter(n -> n % 2 == 0)
               .map(n -> n * n)
               .forEach(System.out::println); // Вывод: 4, 16
    }
}
```

---

### 9. **Уникальный факт**
Следование этим принципам позволяет минимизировать дублирование операций и писать более читаемый функциональный код.